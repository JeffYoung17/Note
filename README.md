# Note

[TOC]

## 计算机组成原理

### 第一篇：概论

```shell
1.计算机系统的组成：
由硬件和软件两部分组成（计算机组成原理讲的是硬件）；

2.计算机组成和计算机体系结构：
一台机器是否具备乘法指令，这是一个结构问题；
实现乘法指令采用什么方式，这是一个组成问题；

3.现代计算机的硬件组成：
CPU，IO设备，主存储器；
CPU和主存称为主机，IO设备称为外部设备；

4.计算机硬件的技术指标：
机器字长：CPU一次能处理的数据的位数，与CPU的寄存器位数有关；
存储容量：分为主存和辅存，=存储单元个数*存储字长（单位：位），然后除以8，用字节（byte）表示容量。
运算速度：发展出来多种标准。由MIPS，百万条指令每秒；或者FLOPS，浮点运算次数每秒。
```

### 第二篇：硬件结构

Ch3-系统总线   
```shell
1.总线的分类：按照连接部件的不同进行分类
片内总线（CPU内部）
系统总线（CPU、主存和IO设备之间的信息传输线）
通信总线（和其他计算机系统或者其它系统之间的通信线）

2.总线的控制：总线上连接着多个部件，包括判优逻辑（仲裁逻辑）和通信控制
（1）判优控制：分为集中式和分布式，集中式指的是控制逻辑统一由一个地方（例如CPU）负责。
集中式判优控制分为：链式查询，计数器定时查询，独立请求
（2）通信控制：通信双方如何知道传输开始、传输结束、如何协调配合。
通信可分为几个阶段：申请分配阶段，寻址阶段，传数阶段，结束阶段。
通常有：同步、异步、半同步和分离式通信四种。
```

Ch4 - 存储器  

```shell
1.分类
按存储介质：半导体，磁表面、光盘

按存取方式：
（1）RAM，计算机的主存采用的类型，任何一个存储单元可以随机存取，和存取时间、存储单元的位置无关。又分为静态RAM（SRAM）和动态RAM（DRAM）
（2）ROM，通常用于存放固定不变的程序；后续派生出EEPROM，Flash Memory（闪存）
（3）串行访问存储器：例如光盘，对存储单元进行读写时，必须按照物理位置的先后顺序。
总结：类比数组和链表的元素访问方式，是寻秩访问还是顺序访问；

按在计算机中的作用：主存，闪存，辅存，缓存（Cache）

2.计算机存储器的层次结构：CPU的寄存器--缓存--主存--辅存
缓存--主存，解决CPU和主存速度不匹配的问题；
主存--辅存，解决存储系统的容量问题；

3.高速缓冲存储器（Cache）
程序访问的局部性原理：通过对典型程序的分析，发现CPU在一定时间内，从主存存取指令或数据的时候，只是对主存的局部地址区域进行访问，即指令和数据的地址是以相对簇聚的方式存在于主存，所以提前将CPU可能用到的内容送入Cache，可以使得CPU在一定时间内只访问Cache。
```

Ch5 - I/O系统  

```shell
1.I/O设备和主机信息传送的方式：程序查询方式，程序中断方式，DMA方式；

2.I/O设备也称为外围设备，外设；

3.I/O接口：通常指主机和I/O设备之间设置的硬件电路，及其对应的软件控制；
按照数据传送的方式可以分为并行接口和串行接口。
```

### 第三篇 中央处理器
Ch6 - 计算机的运算方法

Ch7 - 指令系统：指令的格式、寻址方式、指令系统的分类

```shell
1.指令的一般格式：
操作码和地址码；
（1）操作码的长度可固定，可变化：位数反映了机器的操作种类，例如操作码长度位7位，那么操作种类最多是128种，固定长度的操作码便于硬件设计，译码时间短；
（2）地址码：包括操作数的地址、结果的地址以及下一条指令的地址；可以是主存的、寄存器的甚至IO设备的地址；

2.操作数的类型：地址，数字，字符，逻辑运算；

3.操作类型：数据传送、算数和逻辑运算、移位等；

4.寻址方式：确定本条指令的地址以及下一条执行指令的地址的方法；
分为指令寻址和数据寻址两类；
（1）指令寻址：分为顺序寻址（程序计数器+1的方式）和跳跃寻址；
（2）数据寻址：指令种的地址码 通常不代表 操作数的真实地址，而是形式地址，操作数的真实地址称为有效地址，需要通过寻址方式和形式地址共同确定。

5.RISC（reduced instruction set computer）精简指令系统计算机
理念：用20%常用的指令，组合成80%不常用的指令。
优点：相比于复杂指令系统：
（1）RISC的指令系统的控制器，即硬件部分会更简单；
（2）计算机运行速度提高，译码更快；
（3）便于设计开发等等；
```

Ch8 - CPU的结构和功能
```shell
1.CPU的基本功能：取指令，分析指令，执行指令。

2.CPU的基本组成：算术逻辑单元ALU，控制单元CU，寄存器，中断系统。

3.指令周期：即CPU完成一条指令的时间，包括：
（1）取指周期：取指令并分析；
（2）间指周期：针对地址码不是操作数的有校地址的情况，即形式地址，需要先根据形式地址取出有效地址，再根据有效地址取出操作数。
（3）执行周期
（4）中断周期：在指令执行完后，检查一下是否有中断（主机与IO设备交换信息时），若有，则进行处理。

4.为了提高CPU的速度，有两个方面的考量：
（1）提高器件性能：这不废话么。。集成度更高，体积更小，功耗更低等。。
（2）改进系统结构，开发系统的并行性：
并行性包含同时性和并发性两个方面：
（2.1）同时性指多个事件同一时刻发生；
（2.2）并发性指同一时间段内完成多种功能；
并行性的不同等级：程序级，进程级，指令之间的级别，指令内部的级别。
前两者属于粗粒度，一般通过软件实现，后两者属于细粒度，一般用硬件实现。
```

## 计算机操作系统

linux 0.11内核源码

### L1 什么是操作系统

计算机分为硬件和软件，硬件（裸机）和应用软件之间一层软件，就是操作系统软件，使我们方便、高效地使用硬件。需要管理的硬件有：CPU，内存，磁盘/文件，网络，电源等等。  

总结：操作系统软件 给 上层应用 提供接口 去使用硬件。  

### L2 揭开钢琴的盖子

计算机工作的本质：（CPU）取指，执行。  

上电开机：执行内存中一段固化的代码，即BIOS。  

```
（1）开机自检
（2）将引导扇区的代码(bootsec.s)加载到内存0x7c00处，开始执行。
（3）载入setup模块到内存（即setup.s）
（4）载入system模块到内存（即系统代码）
（5）将CS：IP赋值相应的值，跳转到setup.s执行 // BIOS就完事
```

### L3 操作系统启动

开始执行载入的setup.s代码，完成操作系统启动前的设置。  

```
（1）取光标位置和其他硬件参数
（2）从实模式进入保护模式等等。。。
（3）跳转到system模块执行
```

system模块的第一段代码：head.s  

```
一顿操作，从汇编转成c语言执行，执行init/main.c
```

init/main.c代码：

```
内存，中断，设备，时钟和CPU等的初始化
```

### L4 操作系统接口

操作系统接口：由普通的C代码和操作系统提供的重要函数组成，连接操作系统和应用程序。  

又称之为**系统调用（system call）**。  

程序（应用软件）通过系统调用“进入内核”，从用户态切换到内核态。  

### L5 系统调用的实现

举例：`whoami()`函数显示当前系统的用户名，为什么不设计一个printf函数直接通过`jmp`访问内核中用户名所在处，打印出来呢？  

原因：如果一个**应用程序**比如浏览器可以直接访问内核的内存，那么可以访问到你的系统的用户名和密码。非常地不安全。  

系统调用：从硬件设计上将内核程序和用户程序隔离。  

对于Intel x86，进入内核的唯一方法，就是通过中断指令int。  

系统调用的核心：  

```
（1）编写包含int指令的用户程序代码
（2）操作系统写好中断处理，获取系统调用的编号
（3）操作系统调用编号执行相应的中断代码
```

举例：

**用户程序**`printf()`函数会经过一顿操作“等效”成**系统调用**`write()`（其实就是向显存写内容），而`write()`经过宏定义展开会执行`_syscal13`程序，其中会指定int 0x80中断指令，并且得到_NR_write这个系统调用编号。    

（1）系统调用编号：linux/include/unistd.h 中定义： `#define _NR_write 4`，因此系统调用号为4，

（2）中断函数的执行：漫长的调用之路

```
（a）init/main.c：在`sched_init()`初始化函数中指定了0x80的对应中断处理程序地址为system_call；
（b）linux/kernel/system_call.s：在system_call程序中，有：`call _sys_call_table(,%eax,4)，其中eax即为中断编号；
（c）在linux/include/sys.h中，_sys_call_table[] = {sys_setup,...,sys_write,...}，其中sys_write是真正的执行内容的输出；
```

至于`sys_write`在内核中是怎么样执行的，需要后面的文件读写，IO驱动的知识储备。  

### L6 操作系统历史

批处理操作系统（顺序执行指令），若当前执行的任务涉及到IO读写，相对速度慢，CPU就会限制下来，利用率不高。因此多进程和进程管理的概念萌芽，需要对不同的作业进行调度和切换。  

分时系统（核心：任务切换）。  

### L7 课程学习的任务

CPU管理：

```
CPU到进程的抽象
多进程的基本结构
fork如何工作
```

内存管理：

```
物理地址到虚拟地址
*p = 7访问内存的背后
进程虚拟内存如何产生
```

文件管理：

```
设备到文件的抽象
open，read，write的背后
```

### Part 1 --> CPU部分

#### L8 CPU管理的直观想法

顺序执行指令的CPU通常表现为工作一段时间，停止一段时间，利用率低。  

并发：多道程序同时触发，交替执行。  

除了修改PC寄存器的值，在切换的时候还要切换时的现场（地址，变量值等）。  

进程：即一个运行时的程序需要记录运行时刻的信息。  区别于静态程序。  

#### L9 多进程图像

PCB：记录进程信息的数据结构；  

多进程的组织：PCB+进程的状态+队列；  

多进程的交替执行：队列操作+调度+切换；  

举例：  

```
当前进程变成阻塞态，进入等待队列，操作系统需要从就绪队列中选择一个进程（调度），然后保护现场，切换到该进程。 
```

问题：  

```
多进程之间可能会发生冲突，需要做到地址空间的分离。因此每个进程就有对应的映射表，保证多进程访问的物理地址内存不会冲突。
```

多进程之间也需要合作，例如PDF软件将文件传给负责打印的程序，同时word可能也需要打印。  

进程同步（后面会展开讲）：  

```问题的例子：生产者-消费者问题。
基本概念：对多个相关进程在执行次序上进行协调，使得并发执行的进程之间能按照一定的时序共享系统资源。
经典问题：生产者和消费者问题
```

#### L10 用户级线程

进程有对应的映射表，将进程中地址映射到内存的实际物理地址。  

因此，并发时进程的切换=指令序列的切换+资源的切换。  

线程：

```
特点：依然是并发，避免了进程切换的代价。
一顿操作：创建Create和切换Yield
需要的东西：每个线程对应的（1）TCB，（2）栈（压入调用或者切换结束“回家”的地址），（3）切换使用的PC指针
```

用户级线程的概念：  

```
例如浏览器进程中的下载线程在下载远程的服务器数据，这时候需要进行网卡的IO操作，当然要通过系统调用一顿操作（经过内核来使用硬件），内核觉得太慢了，会跳到其他进程，那么浏览器进程中的线程切换就不起作用了，整个浏览器进程发生阻塞。
```

与之相对应的是核心（内核）级线程： 

``` 
进程中的多线程调度和切换交给内核来完成。
```

#### L11 内核级线程

一个用户级线程对应一个用户栈；  

一个内核级线程对应一套栈（用户栈和内核栈）；  

```
				线程1					线程2
				用户态代码			  用户态代码
				系统调用（中断）	    系统调用（中断）
用户态/内核态分界线----------------------------
				内核态代码  --->(切换)  内核态代码
```

流程：  

```
（1）线程1的用户态代码通过系统调用/中断进入内核时CPU会一顿操作，完成从用户栈到内核栈的切换。
（2）进入内核执行指令（例如IO操作），则引起阻塞后，则内核会进行线程的切换（TCB1和TCB2的切换）。
（3）来到线程2的TCB2部分的程序，最后执行中断返回（iret）。
（4）把内核栈2中的和线程2用户态程序的地址寄存器值取出来，成功到达线程2的用户态程序。
```

#### L12 内核级线程的实现

Linux系统中，init()进程是所有进程的父进程。  

```c
void main(void) {
if(!fork()) {init();}
} // main函数执行完毕，创建出init父进程。init()函数里面会加载运行第一个程序shell
```

举例：fork()`是系统调用：用于创建进程。  

`fork()`中执行`int 0x80`，引起中断。

中断的处理函数中`call sys_fork`。  

`fork()`后**子进程**的返回值为0，会执行`exec(cmd)`。父进程的`fork()`返回值不为0。  

`exec`也是系统调用，对应`call _do_execve`

#### L13 操作系统的那棵“树”

让CPU取指令执行 -->  

但是顺序执行特别碰到IO操作相对速度太慢，利用率太低 -->  

多道程序并发：同时触发，交替执行 -->  

利用一个线程一个栈，TCB，实现PC指针的跳转（用户级线程） -->  

利用一个线程一套栈，TCB，实现跳转（内核级线程，用户栈和内核栈）！  

// 说明：  

父进程在第2行创建子进程A（除了内核态TCB与父进程不同，其他用户态TCB相同），返回0，进入打印A的while循环。  

父进程的fork返回值不为0，则在第3行创建子进程B（同理），子进程B的fork()返回值为0，进入打印B的while循环。  

假如打印A的子进程先进入while循环，那么什么时候打印B呢（需要进行调度切换，不妨设置一个时钟中断，在时钟中断的处理函数里面进行进程的切换）  

```c
1 // 
2 void main(void) {
3    if (!fork()) {while(1) printf("A");} // 父进程创建打印A的子进程
4 	 if (!fork()) {while(1) printf("B");} // 父进程创建打印B的子进程
5    wait(); // 父进程设置为等待阻塞状态，调度切换到其他子进程
6 }
```

#### L14 CPU调度策略

当前进程阻塞，从等待队列中挑选哪个进程继续执行呢？  

直观想法：   FIFO，先来的先调度。  

还是需要引入优先级！  

调度策略的目标：  

```
用时短（周转时间）：任务从开始到结束。

响应快：从操作发生到响应。

系统内耗时间少，吞吐量（完成的任务量）大。
```

矛盾：  

```
响应快-->切换次数多-->内耗大-->吞吐量小
周转时间短-->切换次数少-->响应时间长 等等
```

FCFS：先来先服务；  

SJF（短作业优先）：在FCFS基础上缩短周转时间；  

RR：以时间片为单位，进行轮转，在SJF基础上保证响应时间；  

#### L16 进程同步与信号量

例如：多个进程存在共享的缓冲区，根据缓冲区定义的信号量，“走走停停”，合理有序；  



### Part2 --> 内存部分





### Part3 --> 文件管理部分

### Appendix 操作系统的知识附录

[计算机是如何启动的？](http://www.ruanyifeng.com/blog/2013/02/booting.html)

[为什么主引导记录的内存地址是0x7C00？](http://www.ruanyifeng.com/blog/2015/09/0x7c00.html)